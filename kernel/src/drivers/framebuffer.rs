// =============================================================================
// MinimalOS NextGen — Framebuffer Console Driver
// =============================================================================
//
// Renders text on the UEFI GOP framebuffer. This is the kernel's visual
// output during boot — the text you see on screen when the OS starts.
//
// HOW IT WORKS:
//   1. Limine sets up a pixel-addressable framebuffer via UEFI GOP
//   2. We receive the framebuffer address, dimensions, and pixel format
//   3. We use a built-in bitmap font (8x16 pixels per character)
//   4. To "print" a character, we write the appropriate pixels
//
// PIXEL FORMAT:
//   UEFI GOP typically provides a 32-bit XRGB framebuffer:
//   Each pixel = [Blue: u8, Green: u8, Red: u8, Reserved: u8]
//   (yes, it's BGR in memory, not RGB — little-endian x86 strikes again)
//
// WHY NOT USE UEFI CONSOLE TEXT MODE?
//   Limine exits UEFI boot services before jumping to us.
//   After ExitBootServices(), UEFI's console output service is gone.
//   The only output we have is raw pixel access to the framebuffer.
//
// SCROLLING:
//   When text reaches the bottom of the screen, we scroll by copying
//   the framebuffer contents up by one line height (16 pixels) and
//   clearing the bottom line. This is a memcpy of ~4MB on 1366x768 —
//   takes about 0.3ms on N3710, acceptable for a debug console.
//
// THREAD SAFETY:
//   The framebuffer console is protected by the SERIAL spinlock
//   (since kprintln writes to both serial AND framebuffer atomically).
//   This is a simplification — a future improvement could use a separate
//   lock for the framebuffer.
//
// =============================================================================

use crate::arch::boot::FramebufferInfo;
use crate::sync::spinlock::SpinLock;

// =============================================================================
// Built-in bitmap font (8x16)
// =============================================================================
//
// We use a classic 8x16 VGA-compatible bitmap font. Each character is
// represented as 16 bytes, where each byte is a row of 8 pixels
// (1 bit per pixel, MSB = leftmost).
//
// Example: Letter 'A' (ASCII 65)
//   Row 0:  0b00000000 = ........
//   Row 1:  0b00000000 = ........
//   Row 2:  0b00111100 = ..XXXX..
//   Row 3:  0b01100110 = .XX..XX.
//   Row 4:  0b01100110 = .XX..XX.
//   Row 5:  0b01100110 = .XX..XX.
//   Row 6:  0b01111110 = .XXXXXX.
//   Row 7:  0b01100110 = .XX..XX.
//   Row 8:  0b01100110 = .XX..XX.
//   Row 9:  0b01100110 = .XX..XX.
//   Row 10: 0b01100110 = .XX..XX.
//   Row 11: 0b00000000 = ........
//   Row 12: 0b00000000 = ........
//   Row 13: 0b00000000 = ........
//   Row 14: 0b00000000 = ........
//   Row 15: 0b00000000 = ........
//
// The full font covers ASCII 32 (space) through ASCII 126 (~).
// Non-printable characters render as a filled block.
//
// Including the font data from a separate file keeps this module clean.
// =============================================================================

/// Width of a single character in pixels.
const CHAR_WIDTH: u64 = 8;

/// Height of a single character in pixels.
const CHAR_HEIGHT: u64 = 16;

/// Foreground color for text (light gray — easy on the eyes).
/// Format: 0x00RRGGBB
const FG_COLOR: u32 = 0x00CCCCCC;

/// Background color (dark — classic terminal look).
/// Format: 0x00RRGGBB
const BG_COLOR: u32 = 0x00111111;

// =============================================================================
// Global Console State
// =============================================================================

/// The global framebuffer console state, protected by a spinlock.
///
/// Before initialization, `inner` is `None`. After `init()`, it holds
/// the framebuffer parameters and cursor position.
pub static CONSOLE: SpinLock<Option<Console>> = SpinLock::new(None);

/// The framebuffer console state.
///
/// Tracks the framebuffer parameters and the current cursor position
/// for text rendering. The cursor auto-advances on each character write
/// and wraps/scrolls when it reaches the screen edge or bottom.
pub struct Console {
    /// Raw pointer to the framebuffer pixel data.
    /// Each pixel is 4 bytes (32-bit XRGB).
    buffer: *mut u32,

    /// Width of the framebuffer in pixels.
    width: u64,

    /// Height of the framebuffer in pixels.
    height: u64,

    /// Bytes per row of the framebuffer (may include padding).
    pitch: u64,

    /// Current cursor column (in characters, not pixels).
    cursor_x: u64,

    /// Current cursor row (in characters, not pixels).
    cursor_y: u64,

    /// Maximum number of character columns that fit on screen.
    max_cols: u64,

    /// Maximum number of character rows that fit on screen.
    max_rows: u64,
}

// SAFETY: The framebuffer pointer is valid for the lifetime of the system
// (it's mapped by UEFI and never unmapped). Access is serialized via the
// CONSOLE spinlock.
unsafe impl Send for Console {}

impl Console {
    /// Creates a new Console from framebuffer information.
    ///
    /// Calculates the character grid dimensions from the pixel dimensions
    /// and clears the screen to the background color.
    pub fn new(info: FramebufferInfo) -> Self {
        let max_cols = info.width / CHAR_WIDTH;
        let max_rows = info.height / CHAR_HEIGHT;

        let mut console = Console {
            buffer: info.address as *mut u32,
            width: info.width,
            height: info.height,
            pitch: info.pitch,
            cursor_x: 0,
            cursor_y: 0,
            max_cols,
            max_rows,
        };

        // Clear the screen to background color.
        console.clear();
        console
    }

    /// Clears the entire screen to the background color.
    pub fn clear(&mut self) {
        for y in 0..self.height {
            for x in 0..self.width {
                self.put_pixel(x, y, BG_COLOR);
            }
        }
        self.cursor_x = 0;
        self.cursor_y = 0;
    }

    /// Writes a single character at the current cursor position.
    ///
    /// Handles special characters:
    ///   - `\n` (newline): moves cursor to the start of the next line
    ///   - `\r` (carriage return): moves cursor to the start of current line
    ///   - `\t` (tab): advances to the next 4-column boundary
    ///   - Printable ASCII: renders the character glyph and advances cursor
    ///
    /// Automatically wraps to the next line when cursor reaches the right edge.
    /// Automatically scrolls when cursor reaches the bottom of the screen.
    pub fn write_char(&mut self, c: char) {
        match c {
            '\n' => {
                // Newline: move to start of next line.
                self.cursor_x = 0;
                self.cursor_y += 1;
                self.check_scroll();
            }
            '\r' => {
                // Carriage return: move to start of current line.
                self.cursor_x = 0;
            }
            '\t' => {
                // Tab: advance to next 4-column boundary.
                self.cursor_x = (self.cursor_x + 4) & !3;
                if self.cursor_x >= self.max_cols {
                    self.cursor_x = 0;
                    self.cursor_y += 1;
                    self.check_scroll();
                }
            }
            c if c.is_ascii() && (c as u8) >= 32 => {
                // Printable ASCII character: render the glyph.
                self.draw_char(self.cursor_x, self.cursor_y, c as u8);
                self.cursor_x += 1;
                if self.cursor_x >= self.max_cols {
                    self.cursor_x = 0;
                    self.cursor_y += 1;
                    self.check_scroll();
                }
            }
            _ => {
                // Non-printable: render as a solid block character.
                self.draw_char(self.cursor_x, self.cursor_y, b'?');
                self.cursor_x += 1;
                if self.cursor_x >= self.max_cols {
                    self.cursor_x = 0;
                    self.cursor_y += 1;
                    self.check_scroll();
                }
            }
        }
    }

    /// Writes a string to the console, character by character.
    pub fn write_string(&mut self, s: &str) {
        for c in s.chars() {
            self.write_char(c);
        }
    }

    /// Draws a single character glyph at the given character cell position.
    ///
    /// The character is rendered using the built-in 8x16 bitmap font.
    /// The font data is a simple array: each ASCII character has 16 bytes,
    /// each byte is a row of 8 pixels (MSB = leftmost pixel).
    ///
    /// # Parameters
    /// - `col`: Character column (0-based)
    /// - `row`: Character row (0-based)
    /// - `ascii`: ASCII character code to render
    fn draw_char(&mut self, col: u64, row: u64, ascii: u8) {
        let glyph = get_glyph(ascii);
        let base_x = col * CHAR_WIDTH;
        let base_y = row * CHAR_HEIGHT;

        for (dy, &glyph_row) in glyph.iter().enumerate() {
            for dx in 0..CHAR_WIDTH {
                // Check if this pixel is "on" in the glyph.
                // Bit 7 = leftmost pixel, bit 0 = rightmost pixel.
                let pixel_on = (glyph_row >> (7 - dx)) & 1 == 1;
                let color = if pixel_on { FG_COLOR } else { BG_COLOR };
                self.put_pixel(base_x + dx, base_y + dy as u64, color);
            }
        }
    }

    /// Writes a single pixel to the framebuffer.
    ///
    /// # Parameters
    /// - `x`: Pixel X coordinate (0 = left edge)
    /// - `y`: Pixel Y coordinate (0 = top edge)
    /// - `color`: 32-bit XRGB color value (0x00RRGGBB)
    #[inline(always)]
    fn put_pixel(&mut self, x: u64, y: u64, color: u32) {
        if x >= self.width || y >= self.height {
            return; // Bounds check — don't write outside the framebuffer
        }
        // Calculate the pixel offset.
        // pitch is in BYTES, but our buffer pointer is *mut u32 (4 bytes per element).
        // So we divide pitch by 4 to get the u32 stride per row.
        let offset = y * (self.pitch / 4) + x;
        // SAFETY: We've bounds-checked x and y above. The framebuffer memory
        // was mapped by UEFI and is valid for the lifetime of the system.
        unsafe {
            self.buffer.add(offset as usize).write_volatile(color);
        }
    }

    /// Checks if the cursor has moved past the bottom of the screen.
    /// If so, scrolls the screen up by one line.
    fn check_scroll(&mut self) {
        if self.cursor_y >= self.max_rows {
            self.scroll_up();
            self.cursor_y = self.max_rows - 1;
        }
    }

    /// Scrolls the screen up by one character row (CHAR_HEIGHT pixels).
    ///
    /// This copies each pixel row up by CHAR_HEIGHT pixels and clears
    /// the bottom row. On 1366x768 with 32bpp, this copies about 4MB
    /// of pixel data — takes ~0.3ms on N3710 DDR3L.
    fn scroll_up(&mut self) {
        let row_stride = self.pitch / 4; // u32 elements per row

        // Copy each pixel row up by CHAR_HEIGHT pixels.
        for y in CHAR_HEIGHT..self.height {
            let src_offset = y * row_stride;
            let dst_offset = (y - CHAR_HEIGHT) * row_stride;
            for x in 0..self.width {
                // SAFETY: Bounds are within the framebuffer dimensions.
                unsafe {
                    let pixel = self.buffer.add((src_offset + x) as usize).read_volatile();
                    self.buffer.add((dst_offset + x) as usize).write_volatile(pixel);
                }
            }
        }

        // Clear the bottom row (fill with background color).
        let clear_start_y = self.height - CHAR_HEIGHT;
        for y in clear_start_y..self.height {
            for x in 0..self.width {
                self.put_pixel(x, y, BG_COLOR);
            }
        }
    }
}

/// Implement `core::fmt::Write` for Console so we can use `write!()` macros.
impl core::fmt::Write for Console {
    fn write_str(&mut self, s: &str) -> core::fmt::Result {
        self.write_string(s);
        Ok(())
    }
}

// =============================================================================
// Framebuffer Console Initialization
// =============================================================================

/// Initializes the framebuffer console.
///
/// Must be called during boot after Limine has set up the framebuffer.
/// After this call, kprintln!() output will appear on screen.
///
/// # Arguments
/// - `info`: Framebuffer information from `arch::boot::get_framebuffer_info()`
pub fn init(info: FramebufferInfo) {
    let console = Console::new(info);
    *CONSOLE.lock() = Some(console);
}

/// Writes to the framebuffer console if it has been initialized.
///
/// This is called by the kprint!() macro to display output on screen.
/// If the console hasn't been initialized yet, this is a no-op.
pub fn write_fmt(args: core::fmt::Arguments) {
    use core::fmt::Write;
    let mut console = CONSOLE.lock();
    if let Some(ref mut con) = *console {
        let _ = con.write_fmt(args);
    }
}

// =============================================================================
// Built-in 8x16 Bitmap Font
// =============================================================================
//
// A minimal VGA-compatible bitmap font covering printable ASCII (32-126).
// Each character is 16 bytes (16 rows of 8 pixels each).
//
// This font is embedded directly in the kernel binary. It adds ~1.5KB
// to the kernel size, which is negligible.
// =============================================================================

/// Returns the 16-byte glyph data for an ASCII character.
///
/// For characters outside the printable ASCII range (32-126),
/// returns a filled block glyph (useful for spotting encoding issues).
fn get_glyph(ascii: u8) -> &'static [u8; 16] {
    if ascii >= 32 && ascii <= 126 {
        &FONT_8X16[ascii as usize - 32]
    } else {
        &FONT_8X16[0] // Space character as fallback
    }
}

/// The 8x16 bitmap font data.
///
/// Index: ASCII code - 32 (so index 0 = space, index 1 = '!', etc.)
/// Each entry: 16 bytes, each byte = one row, MSB = leftmost pixel
///
/// This is a standard VGA font. Each character was hand-crafted decades ago
/// by IBM engineers to be legible at very low resolutions — perfect for our
/// 1366x768 boot console.
#[rustfmt::skip]
static FONT_8X16: [[u8; 16]; 95] = [
    // ASCII 32: ' ' (space)
    [0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
    // ASCII 33: '!'
    [0x00,0x00,0x18,0x3C,0x3C,0x3C,0x18,0x18,0x18,0x00,0x18,0x18,0x00,0x00,0x00,0x00],
    // ASCII 34: '"'
    [0x00,0x66,0x66,0x66,0x24,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
    // ASCII 35: '#'
    [0x00,0x00,0x00,0x6C,0x6C,0xFE,0x6C,0x6C,0xFE,0x6C,0x6C,0x00,0x00,0x00,0x00,0x00],
    // ASCII 36: '$'
    [0x18,0x18,0x7C,0xC6,0xC2,0xC0,0x7C,0x06,0x06,0x86,0xC6,0x7C,0x18,0x18,0x00,0x00],
    // ASCII 37: '%'
    [0x00,0x00,0x00,0x00,0xC2,0xC6,0x0C,0x18,0x30,0x60,0xC6,0x86,0x00,0x00,0x00,0x00],
    // ASCII 38: '&'
    [0x00,0x00,0x38,0x6C,0x6C,0x38,0x76,0xDC,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00],
    // ASCII 39: '\''
    [0x00,0x30,0x30,0x30,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
    // ASCII 40: '('
    [0x00,0x00,0x0C,0x18,0x30,0x30,0x30,0x30,0x30,0x30,0x18,0x0C,0x00,0x00,0x00,0x00],
    // ASCII 41: ')'
    [0x00,0x00,0x30,0x18,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x18,0x30,0x00,0x00,0x00,0x00],
    // ASCII 42: '*'
    [0x00,0x00,0x00,0x00,0x00,0x66,0x3C,0xFF,0x3C,0x66,0x00,0x00,0x00,0x00,0x00,0x00],
    // ASCII 43: '+'
    [0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x7E,0x18,0x18,0x00,0x00,0x00,0x00,0x00,0x00],
    // ASCII 44: ','
    [0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x18,0x30,0x00,0x00,0x00],
    // ASCII 45: '-'
    [0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
    // ASCII 46: '.'
    [0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00],
    // ASCII 47: '/'
    [0x00,0x00,0x00,0x00,0x02,0x06,0x0C,0x18,0x30,0x60,0xC0,0x80,0x00,0x00,0x00,0x00],
    // ASCII 48: '0'
    [0x00,0x00,0x7C,0xC6,0xC6,0xCE,0xDE,0xF6,0xE6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00],
    // ASCII 49: '1'
    [0x00,0x00,0x18,0x38,0x78,0x18,0x18,0x18,0x18,0x18,0x18,0x7E,0x00,0x00,0x00,0x00],
    // ASCII 50: '2'
    [0x00,0x00,0x7C,0xC6,0x06,0x0C,0x18,0x30,0x60,0xC0,0xC6,0xFE,0x00,0x00,0x00,0x00],
    // ASCII 51: '3'
    [0x00,0x00,0x7C,0xC6,0x06,0x06,0x3C,0x06,0x06,0x06,0xC6,0x7C,0x00,0x00,0x00,0x00],
    // ASCII 52: '4'
    [0x00,0x00,0x0C,0x1C,0x3C,0x6C,0xCC,0xFE,0x0C,0x0C,0x0C,0x1E,0x00,0x00,0x00,0x00],
    // ASCII 53: '5'
    [0x00,0x00,0xFE,0xC0,0xC0,0xC0,0xFC,0x06,0x06,0x06,0xC6,0x7C,0x00,0x00,0x00,0x00],
    // ASCII 54: '6'
    [0x00,0x00,0x38,0x60,0xC0,0xC0,0xFC,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00],
    // ASCII 55: '7'
    [0x00,0x00,0xFE,0xC6,0x06,0x06,0x0C,0x18,0x30,0x30,0x30,0x30,0x00,0x00,0x00,0x00],
    // ASCII 56: '8'
    [0x00,0x00,0x7C,0xC6,0xC6,0xC6,0x7C,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00],
    // ASCII 57: '9'
    [0x00,0x00,0x7C,0xC6,0xC6,0xC6,0x7E,0x06,0x06,0x06,0x0C,0x78,0x00,0x00,0x00,0x00],
    // ASCII 58: ':'
    [0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00],
    // ASCII 59: ';'
    [0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x30,0x00,0x00,0x00,0x00],
    // ASCII 60: '<'
    [0x00,0x00,0x00,0x06,0x0C,0x18,0x30,0x60,0x30,0x18,0x0C,0x06,0x00,0x00,0x00,0x00],
    // ASCII 61: '='
    [0x00,0x00,0x00,0x00,0x00,0x7E,0x00,0x00,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
    // ASCII 62: '>'
    [0x00,0x00,0x00,0x60,0x30,0x18,0x0C,0x06,0x0C,0x18,0x30,0x60,0x00,0x00,0x00,0x00],
    // ASCII 63: '?'
    [0x00,0x00,0x7C,0xC6,0xC6,0x0C,0x18,0x18,0x18,0x00,0x18,0x18,0x00,0x00,0x00,0x00],
    // ASCII 64: '@'
    [0x00,0x00,0x00,0x7C,0xC6,0xC6,0xDE,0xDE,0xDE,0xDC,0xC0,0x7C,0x00,0x00,0x00,0x00],
    // ASCII 65: 'A'
    [0x00,0x00,0x10,0x38,0x6C,0xC6,0xC6,0xFE,0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00],
    // ASCII 66: 'B'
    [0x00,0x00,0xFC,0x66,0x66,0x66,0x7C,0x66,0x66,0x66,0x66,0xFC,0x00,0x00,0x00,0x00],
    // ASCII 67: 'C'
    [0x00,0x00,0x3C,0x66,0xC2,0xC0,0xC0,0xC0,0xC0,0xC2,0x66,0x3C,0x00,0x00,0x00,0x00],
    // ASCII 68: 'D'
    [0x00,0x00,0xF8,0x6C,0x66,0x66,0x66,0x66,0x66,0x66,0x6C,0xF8,0x00,0x00,0x00,0x00],
    // ASCII 69: 'E'
    [0x00,0x00,0xFE,0x66,0x62,0x68,0x78,0x68,0x60,0x62,0x66,0xFE,0x00,0x00,0x00,0x00],
    // ASCII 70: 'F'
    [0x00,0x00,0xFE,0x66,0x62,0x68,0x78,0x68,0x60,0x60,0x60,0xF0,0x00,0x00,0x00,0x00],
    // ASCII 71: 'G'
    [0x00,0x00,0x3C,0x66,0xC2,0xC0,0xC0,0xDE,0xC6,0xC6,0x66,0x3A,0x00,0x00,0x00,0x00],
    // ASCII 72: 'H'
    [0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xFE,0xC6,0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00],
    // ASCII 73: 'I'
    [0x00,0x00,0x3C,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00],
    // ASCII 74: 'J'
    [0x00,0x00,0x1E,0x0C,0x0C,0x0C,0x0C,0x0C,0xCC,0xCC,0xCC,0x78,0x00,0x00,0x00,0x00],
    // ASCII 75: 'K'
    [0x00,0x00,0xE6,0x66,0x66,0x6C,0x78,0x78,0x6C,0x66,0x66,0xE6,0x00,0x00,0x00,0x00],
    // ASCII 76: 'L'
    [0x00,0x00,0xF0,0x60,0x60,0x60,0x60,0x60,0x60,0x62,0x66,0xFE,0x00,0x00,0x00,0x00],
    // ASCII 77: 'M'
    [0x00,0x00,0xC6,0xEE,0xFE,0xFE,0xD6,0xC6,0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00],
    // ASCII 78: 'N'
    [0x00,0x00,0xC6,0xE6,0xF6,0xFE,0xDE,0xCE,0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00],
    // ASCII 79: 'O'
    [0x00,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00],
    // ASCII 80: 'P'
    [0x00,0x00,0xFC,0x66,0x66,0x66,0x7C,0x60,0x60,0x60,0x60,0xF0,0x00,0x00,0x00,0x00],
    // ASCII 81: 'Q'
    [0x00,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xD6,0xDE,0x7C,0x0C,0x0E,0x00,0x00],
    // ASCII 82: 'R'
    [0x00,0x00,0xFC,0x66,0x66,0x66,0x7C,0x6C,0x66,0x66,0x66,0xE6,0x00,0x00,0x00,0x00],
    // ASCII 83: 'S'
    [0x00,0x00,0x7C,0xC6,0xC6,0x60,0x38,0x0C,0x06,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00],
    // ASCII 84: 'T'
    [0x00,0x00,0xFF,0xDB,0x99,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00],
    // ASCII 85: 'U'
    [0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00],
    // ASCII 86: 'V'
    [0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x6C,0x38,0x10,0x00,0x00,0x00,0x00],
    // ASCII 87: 'W'
    [0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xD6,0xD6,0xD6,0xFE,0xEE,0x6C,0x00,0x00,0x00,0x00],
    // ASCII 88: 'X'
    [0x00,0x00,0xC6,0xC6,0x6C,0x7C,0x38,0x38,0x7C,0x6C,0xC6,0xC6,0x00,0x00,0x00,0x00],
    // ASCII 89: 'Y'
    [0x00,0x00,0xC3,0xC3,0x66,0x3C,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00],
    // ASCII 90: 'Z'
    [0x00,0x00,0xFE,0xC6,0x86,0x0C,0x18,0x30,0x60,0xC2,0xC6,0xFE,0x00,0x00,0x00,0x00],
    // ASCII 91: '['
    [0x00,0x00,0x3C,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x3C,0x00,0x00,0x00,0x00],
    // ASCII 92: '\'
    [0x00,0x00,0x00,0x80,0xC0,0xE0,0x70,0x38,0x1C,0x0E,0x06,0x02,0x00,0x00,0x00,0x00],
    // ASCII 93: ']'
    [0x00,0x00,0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3C,0x00,0x00,0x00,0x00],
    // ASCII 94: '^'
    [0x10,0x38,0x6C,0xC6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
    // ASCII 95: '_'
    [0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00],
    // ASCII 96: '`'
    [0x30,0x30,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
    // ASCII 97: 'a'
    [0x00,0x00,0x00,0x00,0x00,0x78,0x0C,0x7C,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00],
    // ASCII 98: 'b'
    [0x00,0x00,0xE0,0x60,0x60,0x78,0x6C,0x66,0x66,0x66,0x66,0x7C,0x00,0x00,0x00,0x00],
    // ASCII 99: 'c'
    [0x00,0x00,0x00,0x00,0x00,0x7C,0xC6,0xC0,0xC0,0xC0,0xC6,0x7C,0x00,0x00,0x00,0x00],
    // ASCII 100: 'd'
    [0x00,0x00,0x1C,0x0C,0x0C,0x3C,0x6C,0xCC,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00],
    // ASCII 101: 'e'
    [0x00,0x00,0x00,0x00,0x00,0x7C,0xC6,0xFE,0xC0,0xC0,0xC6,0x7C,0x00,0x00,0x00,0x00],
    // ASCII 102: 'f'
    [0x00,0x00,0x1C,0x36,0x32,0x30,0x78,0x30,0x30,0x30,0x30,0x78,0x00,0x00,0x00,0x00],
    // ASCII 103: 'g'
    [0x00,0x00,0x00,0x00,0x00,0x76,0xCC,0xCC,0xCC,0xCC,0xCC,0x7C,0x0C,0xCC,0x78,0x00],
    // ASCII 104: 'h'
    [0x00,0x00,0xE0,0x60,0x60,0x6C,0x76,0x66,0x66,0x66,0x66,0xE6,0x00,0x00,0x00,0x00],
    // ASCII 105: 'i'
    [0x00,0x00,0x18,0x18,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00],
    // ASCII 106: 'j'
    [0x00,0x00,0x06,0x06,0x00,0x0E,0x06,0x06,0x06,0x06,0x06,0x06,0x66,0x66,0x3C,0x00],
    // ASCII 107: 'k'
    [0x00,0x00,0xE0,0x60,0x60,0x66,0x6C,0x78,0x78,0x6C,0x66,0xE6,0x00,0x00,0x00,0x00],
    // ASCII 108: 'l'
    [0x00,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00],
    // ASCII 109: 'm'
    [0x00,0x00,0x00,0x00,0x00,0xEC,0xFE,0xD6,0xD6,0xD6,0xD6,0xC6,0x00,0x00,0x00,0x00],
    // ASCII 110: 'n'
    [0x00,0x00,0x00,0x00,0x00,0xDC,0x66,0x66,0x66,0x66,0x66,0x66,0x00,0x00,0x00,0x00],
    // ASCII 111: 'o'
    [0x00,0x00,0x00,0x00,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00],
    // ASCII 112: 'p'
    [0x00,0x00,0x00,0x00,0x00,0xDC,0x66,0x66,0x66,0x66,0x66,0x7C,0x60,0x60,0xF0,0x00],
    // ASCII 113: 'q'
    [0x00,0x00,0x00,0x00,0x00,0x76,0xCC,0xCC,0xCC,0xCC,0xCC,0x7C,0x0C,0x0C,0x1E,0x00],
    // ASCII 114: 'r'
    [0x00,0x00,0x00,0x00,0x00,0xDC,0x76,0x66,0x60,0x60,0x60,0xF0,0x00,0x00,0x00,0x00],
    // ASCII 115: 's'
    [0x00,0x00,0x00,0x00,0x00,0x7C,0xC6,0x60,0x38,0x0C,0xC6,0x7C,0x00,0x00,0x00,0x00],
    // ASCII 116: 't'
    [0x00,0x00,0x10,0x30,0x30,0xFC,0x30,0x30,0x30,0x30,0x36,0x1C,0x00,0x00,0x00,0x00],
    // ASCII 117: 'u'
    [0x00,0x00,0x00,0x00,0x00,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00],
    // ASCII 118: 'v'
    [0x00,0x00,0x00,0x00,0x00,0xC3,0xC3,0x66,0x66,0x3C,0x3C,0x18,0x00,0x00,0x00,0x00],
    // ASCII 119: 'w'
    [0x00,0x00,0x00,0x00,0x00,0xC6,0xC6,0xD6,0xD6,0xD6,0xFE,0x6C,0x00,0x00,0x00,0x00],
    // ASCII 120: 'x'
    [0x00,0x00,0x00,0x00,0x00,0xC6,0x6C,0x38,0x38,0x38,0x6C,0xC6,0x00,0x00,0x00,0x00],
    // ASCII 121: 'y'
    [0x00,0x00,0x00,0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7E,0x06,0x0C,0xF8,0x00],
    // ASCII 122: 'z'
    [0x00,0x00,0x00,0x00,0x00,0xFE,0xCC,0x18,0x30,0x60,0xC6,0xFE,0x00,0x00,0x00,0x00],
    // ASCII 123: '{'
    [0x00,0x00,0x0E,0x18,0x18,0x18,0x70,0x18,0x18,0x18,0x18,0x0E,0x00,0x00,0x00,0x00],
    // ASCII 124: '|'
    [0x00,0x00,0x18,0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00],
    // ASCII 125: '}'
    [0x00,0x00,0x70,0x18,0x18,0x18,0x0E,0x18,0x18,0x18,0x18,0x70,0x00,0x00,0x00,0x00],
    // ASCII 126: '~'
    [0x00,0x00,0x76,0xDC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
];
